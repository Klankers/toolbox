{
  "developer_guide": [
    {
      "source": "from toolbox.steps.base_step import BaseStep, register_step\n\n@register_step\nclass MyNewStep(BaseStep):\n    ...\n",
      "names": [],
      "example": {
        "document": "developer_guide",
        "ref_id": "how-to-add-a-new-step",
        "headings": [
          "Developer Guide",
          "How to add a new step"
        ]
      },
      "doc_lineno": 32
    },
    {
      "source": "from toolbox.steps.base_step import BaseStep, register_step\n\n@register_step\nclass MyNewStep(BaseStep):\n\n    step_name = \"My New Step\"\n",
      "names": [],
      "example": {
        "document": "developer_guide",
        "ref_id": "how-to-add-a-new-step",
        "headings": [
          "Developer Guide",
          "How to add a new step"
        ]
      },
      "doc_lineno": 40
    },
    {
      "source": "from toolbox.steps.base_step import BaseStep, register_step\n\n@register_step\nclass MyNewStep(BaseStep):\n    step_name = \"My New Step\"\n     \n    def run(self):\n        # Your processing logic here\n        return self.context        \n",
      "names": [],
      "example": {
        "document": "developer_guide",
        "ref_id": "how-to-add-a-new-step",
        "headings": [
          "Developer Guide",
          "How to add a new step"
        ]
      },
      "doc_lineno": 49
    },
    {
      "source": "from toolbox.steps.base_step import BaseStep, register_step\n\n@register_step\nclass MyNewStep(BaseStep):\n    step_name = \"My New Step\"\n     \n    def run(self):\n        # Your processing logic here\n        return self.context\n     \n    def generate_diagnostics(self):\n        # Your diagnostics logic here\n        pass\n",
      "names": [],
      "example": {
        "document": "developer_guide",
        "ref_id": "how-to-add-a-new-step",
        "headings": [
          "Developer Guide",
          "How to add a new step"
        ]
      },
      "doc_lineno": 61
    },
    {
      "source": "from toolbox.steps.base_step import BaseStep, register_step\nfrom toolbox.utils.qc_handling import QCHandlingMixin\n\n@register_step\nclass MyNewStep(BaseStep):\n    step_name = \"My New Step\"\n     \n    def run(self):\n        # Before any processing happens:\n        self.filter_qc() # This filters specified QC out of this steps instance of self.data and stores them separately\n        \n        # Your processing logic here. Always use self.data to access your processing inputs as this is what has been filtered\n        # --------- EXAMPLE ---------\n        self.data[\"C\"] = self.data[\"A\"] * self.data[\"B\"]\n        self.context[\"data\"] = self.data\n        # ---------------------------\n        \n        return self.context\n        \n        self.reconstruct_data() # Add the filtered-out data back in, or retain their replacements depending on user config\n        self.update_qc() # Update the flags of the filtered data\n        \n        # If a new variable was added, we need to make sure it gets it's own QC column derived from its parents QC.\n        # Use self.generate_qc() to do this. If no new variables were added then this is not necessary.\n        # --------- EXAMPLE ---------\n        self.generate_qc({\"C_QC\": [\"A_QC\", \"B_QC\"]})\n        # ---------------------------\n    \n    def generate_diagnostics(self):\n        # Your diagnostics logic here\n        pass\n",
      "names": [],
      "example": {
        "document": "developer_guide",
        "ref_id": "adding-qc-handling-to-a-step",
        "headings": [
          "Developer Guide",
          "How to add a new step",
          "Adding QC handling to a step"
        ]
      },
      "doc_lineno": 98
    },
    {
      "source": "from toolbox.steps.base_test import BaseTest, register_qc, flag_cols\n\n@register_qc\nclass MyNewTest(BaseTest):\n    ...\n",
      "names": [],
      "example": {
        "document": "developer_guide",
        "ref_id": "how-to-add-a-new-qc-test",
        "headings": [
          "Developer Guide",
          "How to add a new QC test"
        ]
      },
      "doc_lineno": 179
    },
    {
      "source": "from toolbox.steps.base_test import BaseTest, register_qc, flag_cols\n\n@register_qc\nclass MyNewTest(BaseTest):\n    test_name = \"my new test\"  # This is how you should call the test in config. See below...\n    expected_parameters = {'A_cutoff': 1}  # These are the test parameters that we may expect from the user. The value for each key is the default.\n    required_variables = ['A']  # These are the variables that are required for test execution. This is cross-referenced against the data vars in context\n    qc_outputs = ['A_QC'] # These are the QC outputs. These are references that help \"Apply QC\" update existing QC in the data\n",
      "names": [],
      "example": {
        "document": "developer_guide",
        "ref_id": "how-to-add-a-new-qc-test",
        "headings": [
          "Developer Guide",
          "How to add a new QC test"
        ]
      },
      "doc_lineno": 187
    },
    {
      "source": "from toolbox.steps.base_test import BaseTest, register_qc, flag_cols\n\n@register_qc\nclass MyNewTest(BaseTest):\n    test_name = \"my new test\"\n    expected_parameters = {'A_cutoff': 1}\n    required_variables = ['A']\n    qc_outputs = ['A_QC']\n\n    def return_qc(self):\n        # IMPORTANT: Make sure you access the data with self.data\n        # self.flags should be an xarray Dataset with data_vars that hold the \"{variable}_QC\" columns produced by the test\n        return self.flags\n\n    def plot_diagnostics(self):\n        # Add your diagnostic plotting here\n        ...\n",
      "names": [],
      "example": {
        "document": "developer_guide",
        "ref_id": "how-to-add-a-new-qc-test",
        "headings": [
          "Developer Guide",
          "How to add a new QC test"
        ]
      },
      "doc_lineno": 199
    }
  ],
  "index": []
}